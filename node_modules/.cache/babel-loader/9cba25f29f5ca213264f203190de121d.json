{"ast":null,"code":"import { db, FirebaseTimestamp } from \"../../firebase/index\";\nimport { push } from \"connected-react-router\";\nimport { fetchProductsAction, deleteProductsAction } from \"./actions\";\nconst productsRef = db.collection(\"products\"); // 商品を削除するメソット\n\nexport const deleteProduct = id => {\n  return async (dispatch, getState) => {\n    productsRef.doc(id).delete().then(() => {\n      const prevState = getState().products.list;\n      const nextProducts = prevState.filter(product => product.id !== id);\n      dispatch(deleteProductsAction(nextProducts));\n    });\n  };\n}; // firebaseから商品情報を取得\n\nexport const fetchProducts = () => {\n  return async dispatch => {\n    productsRef.orderBy('updated_at', 'desc').get().then(snapshots => {\n      const productList = [];\n      snapshots.forEach(snapshot => {\n        const product = snapshot.data();\n        productList.push(product);\n      });\n      dispatch(fetchProductsAction(productList));\n    });\n  };\n}; // カート商品の注文の処理\n\nexport const orderProduct = (productsInCart, price) => {\n  return async (dispatch, getState) => {\n    const uid = getState.uid; // 現在のログインユーザーの取得\n\n    const userRef = db.collection('users').doc(uid); // 現在のログインユーザーのfirebase情報取得\n\n    const timestamp = FirebaseTimestamp.now(); // 現在時刻の取得\n\n    let products = {}; // カートの商品を一旦格納する\n\n    let soldOutProducts = []; // 売り切れ商品\n\n    const batch = db.batch(); // カート内の商品1つ1つに対して処理を行う\n\n    for (const product of productsInCart) {\n      const snapshot = await productsRef.doc(product.productId).get(); // カート内の商品idの取得\n\n      const sizes = snapshot.data().sizes; // firebaseのproductコレクションからsize情報を取得\n      // sizeのオブジェクトの個数を減らす処理\n\n      const updateSizes = sizes.map(size => {\n        // カート商品と一致している場合\n        if (size.size === product.size) {\n          //  カート内部に入れている間に商品が購入された時の処理\n          if (size.quantity === 0) {\n            soldOutProducts.push(product.name);\n            return size;\n          } //  新しいサイズのオブジェクトを作成\n\n\n          return {\n            size: size.size,\n            quantity: size.quantity - 1\n          };\n        } else {\n          // 個数の変更はなくそのまま返す\n          return size;\n        }\n      }); // 注文履歴を残す\n\n      products[product.productId] = {\n        id: product.productId,\n        images: product.images,\n        name: product.name,\n        price: product.price,\n        size: product.size\n      }; // バッチ処理を記述する\n\n      batch.update(productsRef.doc(product.productId), {\n        sizes: updateSizes\n      });\n      batch.delete(userRef.collection('cart').doc(product.cartId));\n    } //  在庫がない商品が存在した場合は処理を起こさない\n    //  for文の外で実装を行う\n\n\n    if (soldOutProducts.length > 0) {\n      const errormessage = soldOutProducts.length > 1 ? soldOutProducts.join('と') : soldOutProducts[0];\n      alert('大変申し訳ございません' + errormessage + 'は在庫切れとなったため注文処理を中断しました');\n      return false;\n    } else {\n      // 先ほどのbatch処理を全て行う\n      batch.commit().then(() => {\n        // firebaseに注文履歴を残す\n        const orderRef = userRef.collection('orders').doc();\n        const date = timestamp.toDate(); // Calculate shipping date which is the date after 3 days\n\n        const shippingDate = FirebaseTimestamp.fromDate(new Date(date.setDate(date.getDate() + 3)));\n        const history = {\n          amount: amount,\n          created_at: timestamp,\n          id: orderRef.id,\n          products: products,\n          shipping_date: shippingDate\n        };\n      }).catch(() => {\n        alert('注文処理に失敗しました。通信環境もご確認の、もう一度お試しください');\n      });\n    }\n  };\n};\nexport const saveProduct = (id, name, description, category, gender, price, images, sizes) => {\n  return async dispatch => {\n    const timestamp = FirebaseTimestamp.now();\n    const data = {\n      category: category,\n      description: description,\n      gender: gender,\n      images: images,\n      name: name,\n      price: parseInt(price, 10),\n      updated_at: timestamp,\n      sizes: sizes\n    };\n\n    if (id === \"\") {\n      const ref = productsRef.doc();\n      data.created_at = timestamp;\n      id = ref.id;\n      data.id = id;\n    }\n\n    return productsRef.doc(id).set(data, {\n      merge: true\n    }).then(() => {\n      dispatch(push('/'));\n    }).catch(error => {\n      throw new Error(error);\n    });\n  };\n};","map":{"version":3,"sources":["/Users/itoukazunari/Desktop/ec-app/src/reducks/products/operations.js"],"names":["db","FirebaseTimestamp","push","fetchProductsAction","deleteProductsAction","productsRef","collection","deleteProduct","id","dispatch","getState","doc","delete","then","prevState","products","list","nextProducts","filter","product","fetchProducts","orderBy","get","snapshots","productList","forEach","snapshot","data","orderProduct","productsInCart","price","uid","userRef","timestamp","now","soldOutProducts","batch","productId","sizes","updateSizes","map","size","quantity","name","images","update","cartId","length","errormessage","join","alert","commit","orderRef","date","toDate","shippingDate","fromDate","Date","setDate","getDate","history","amount","created_at","shipping_date","catch","saveProduct","description","category","gender","parseInt","updated_at","ref","set","merge","error","Error"],"mappings":"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","sourcesContent":["import { db, FirebaseTimestamp } from \"../../firebase/index\";\nimport { push } from \"connected-react-router\";\nimport {fetchProductsAction, deleteProductsAction} from \"./actions\"\n\nconst productsRef = db.collection(\"products\");\n\n// 商品を削除するメソット\nexport const deleteProduct = (id)=>{\n  return async(dispatch, getState) => {\n      productsRef.doc(id).delete()\n      .then(()=>{\n          const prevState = getState().products.list;\n         const nextProducts = prevState.filter(product => product.id !== id)\n          dispatch(deleteProductsAction(nextProducts))\n      })\n  }\n}\n\n// firebaseから商品情報を取得\nexport const fetchProducts = () => {\n  \n  return async(dispatch) => {\n      productsRef.orderBy('updated_at', 'desc').get().then(snapshots => {\n          const productList = []\n          snapshots.forEach(snapshot => {\n            const product = snapshot.data();\n            productList.push(product);\n          })\n          dispatch(fetchProductsAction(productList))\n      })\n  }\n}\n\n// カート商品の注文の処理\nexport const orderProduct = (productsInCart, price) => {\n    return async(dispatch, getState) => {\n\n      const uid = getState.uid; // 現在のログインユーザーの取得\n      const userRef = db.collection('users').doc(uid) // 現在のログインユーザーのfirebase情報取得\n      const timestamp = FirebaseTimestamp.now() // 現在時刻の取得\n\n      let products = {}; // カートの商品を一旦格納する\n      let soldOutProducts = []; // 売り切れ商品\n\n      const batch = db.batch();\n\n      // カート内の商品1つ1つに対して処理を行う\n      for(const product of productsInCart){\n        const snapshot = await  productsRef.doc(product.productId).get(); // カート内の商品idの取得\n        const sizes = snapshot.data().sizes; // firebaseのproductコレクションからsize情報を取得\n\n        // sizeのオブジェクトの個数を減らす処理\n        const updateSizes = sizes.map(size => {\n          // カート商品と一致している場合\n          if(size.size === product.size){\n            //  カート内部に入れている間に商品が購入された時の処理\n             if (size.quantity === 0){\n                soldOutProducts.push(product.name);\n                return size\n             }\n            //  新しいサイズのオブジェクトを作成\n             return{\n               size: size.size,\n               quantity: size.quantity - 1\n             }\n          }else{\n            // 個数の変更はなくそのまま返す\n            return size\n          }\n        });\n        // 注文履歴を残す\n        products[product.productId] = {\n              id: product.productId,\n              images: product.images,\n              name: product.name,\n              price: product.price,\n              size: product.size\n          };\n\n        // バッチ処理を記述する\n         batch.update(\n          productsRef.doc(product.productId),\n            {sizes:updateSizes}\n        )\n\n        batch.delete(\n          userRef.collection('cart').doc(product.cartId)\n        )\n      }\n\n       //  在庫がない商品が存在した場合は処理を起こさない\n      //  for文の外で実装を行う\n        if(soldOutProducts.length > 0) {\n          const errormessage = (soldOutProducts.length > 1) ? \n            soldOutProducts.join('と') :\n            soldOutProducts[0];\n          alert('大変申し訳ございません' + errormessage + 'は在庫切れとなったため注文処理を中断しました')\n          return false\n        }else{\n            // 先ほどのbatch処理を全て行う\n          batch.commit()\n            .then(()=>{\n              // firebaseに注文履歴を残す\n                const orderRef = userRef.collection('orders').doc();\n                const date = timestamp.toDate();\n                // Calculate shipping date which is the date after 3 days\n                const shippingDate = FirebaseTimestamp.fromDate(new Date(date.setDate(date.getDate() + 3)));\n\n                const history = {\n                  amount: amount,\n                  created_at: timestamp,\n                  id: orderRef.id,\n                  products: products,\n                  shipping_date: shippingDate\n                }\n\n            }).catch(()=>{\n              alert('注文処理に失敗しました。通信環境もご確認の、もう一度お試しください')\n            })\n        }\n    }\n}\n\nexport const saveProduct = (\n  id,\n  name,\n  description,\n  category,\n  gender,\n  price,\n  images,\n  sizes\n) => {\n  return async (dispatch) => {\n    const timestamp = FirebaseTimestamp.now();\n\n      const data = {\n        category: category,\n        description: description,\n        gender: gender,\n        images: images,\n        name: name,\n        price: parseInt(price, 10),\n        updated_at: timestamp,\n        sizes:sizes\n      }\n\n      if (id === \"\") {\n            const ref = productsRef.doc()\n            data.created_at = timestamp;\n            id = ref.id;\n            data.id = id;\n        }\n\n     return productsRef.doc(id).set(data, {merge: true})\n            .then(() => {\n                dispatch(push('/'))\n            }).catch((error) => {\n                throw new Error(error)\n            })\n    \n  };\n};"]},"metadata":{},"sourceType":"module"}